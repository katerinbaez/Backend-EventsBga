const { Manager } = require('../models/Manager');
const { Event } = require('../models/Event');

// Importar los modelos para disponibilidad y horarios bloqueados
const SpaceAvailability = require('../models/SpaceAvailability');
const BlockedSlot = require('../models/BlockedSlot');

// Obtener datos del espacio cultural por ID de manager
exports.getSpaceByManagerId = async (req, res) => {
  try {
    const { managerId } = req.params;

    const manager = await Manager.findOne({ where: { userId: managerId } });
    if (!manager) {
      return res.status(404).json({ success: false, message: 'Espacio cultural no encontrado' });
    }

    return res.status(200).json({
      success: true,
      space: manager
    });
  } catch (error) {
    console.error('Error al obtener espacio cultural:', error);
    return res.status(500).json({ 
      success: false, 
      message: 'Error al obtener datos del espacio cultural',
      error: error.message
    });
  }
};

// Obtener configuraci√≥n de disponibilidad
exports.getAvailability = async (req, res) => {
  try {
    const { managerId } = req.params;
    const { date } = req.query;
    
    console.log(`üîç Obteniendo disponibilidad para manager: ${managerId}${date ? `, fecha: ${date}` : ''}`);
    
    // Verificar si el manager existe
    const manager = await Manager.findOne({ where: { userId: managerId } });
    if (!manager) {
      return res.status(404).json({ success: false, message: 'Gestor cultural no encontrado' });
    }
    
    // Construir condici√≥n de b√∫squeda
    const whereCondition = { 
      managerId: manager.id
    };
    
    // Si hay fecha espec√≠fica, buscar por esa fecha
    if (date) {
      whereCondition.date = date;
      console.log(`üîç Buscando disponibilidad para fecha espec√≠fica: ${date}`);
    } else {
      whereCondition.date = null;
      console.log('üîç Buscando disponibilidad recurrente (sin fecha espec√≠fica)');
    }
    
    // Buscar registros de disponibilidad
    const availabilityRecords = await SpaceAvailability.findAll({ 
      where: whereCondition 
    });
    
    console.log(`üìä Registros encontrados: ${availabilityRecords.length}`);

    // Si no hay registros, crear disponibilidad por defecto
    if (availabilityRecords.length === 0) {
      // Crear disponibilidad por defecto (todos los d√≠as, horario comercial)
      const availability = {};
      for (let day = 0; day <= 6; day++) {
        // Horario de 8am a 8pm por defecto
        const availableHours = Array.from({ length: 13 }, (_, i) => i + 8);
        availability[day] = availableHours;
        
        // Guardar en la base de datos
        await SpaceAvailability.create({
          managerId: manager.id,
          dayOfWeek: day,
          hourSlots: availableHours,
          date: date ? date : null
        });
      }

      return res.status(200).json({
        success: true,
        availability,
        isSpecificDate: !!date
      });
    }

    // Formatear resultado
    const availability = {};
    availabilityRecords.forEach(record => {
      availability[record.dayOfWeek] = record.hourSlots;
    });

    return res.status(200).json({
      success: true,
      availability,
      isSpecificDate: !!date
    });
  } catch (error) {
    console.error('Error al obtener disponibilidad:', error);
    return res.status(500).json({ 
      success: false, 
      message: 'Error al obtener configuraci√≥n de disponibilidad',
      error: error.message
    });
  }
};

// Actualizar configuraci√≥n de disponibilidad
exports.updateAvailability = async (req, res) => {
  try {
    const { managerId } = req.params;
    const { availability, specificDate } = req.body;
    
    console.log(`üîç Actualizando disponibilidad para manager: ${managerId}${specificDate ? `, fecha: ${specificDate}` : ', fecha: No especificada'}`);
    console.log('üìÖ Datos recibidos:', JSON.stringify({ 
      availability: Object.keys(availability).length + ' d√≠as', 
      specificDate 
    }));
    
    // Decodificar el ID si viene codificado en la URL
    const decodedManagerId = decodeURIComponent(managerId);
    console.log(`üîç ID decodificado: ${decodedManagerId}`);
    
    // Verificar si el manager existe
    const manager = await Manager.findOne({ where: { userId: decodedManagerId } });
    if (!manager) {
      console.log(`‚ùå Manager no encontrado: ${decodedManagerId}`);
      return res.status(404).json({ success: false, message: 'Gestor cultural no encontrado' });
    }
    
    console.log(`‚úÖ Manager encontrado: ${manager.id}, userId: ${manager.userId}`);

    // Si hay fecha espec√≠fica, eliminar configuraciones anteriores para esa fecha
    if (specificDate) {
      try {
        console.log(`üóëÔ∏è Eliminando configuraciones anteriores para la fecha: ${specificDate}`);
        
        // Eliminar usando tanto el ID como el userId para asegurar que se eliminen todos los registros
        const deleted1 = await SpaceAvailability.destroy({
          where: {
            managerId: manager.id,
            date: specificDate
          }
        });
        
        const deleted2 = await SpaceAvailability.destroy({
          where: {
            managerId: decodedManagerId,
            date: specificDate
          }
        });
        
        console.log(`üóëÔ∏è Se eliminaron ${deleted1 + deleted2} configuraciones anteriores`);
      } catch (deleteError) {
        console.error('Error al eliminar configuraciones anteriores:', deleteError);
      }
    } else {
      // Si es configuraci√≥n general, eliminar configuraciones generales anteriores
      try {
        console.log(`üóëÔ∏è Eliminando configuraciones generales anteriores`);
        
        const deleted1 = await SpaceAvailability.destroy({
          where: {
            managerId: manager.id,
            date: null
          }
        });
        
        const deleted2 = await SpaceAvailability.destroy({
          where: {
            managerId: decodedManagerId,
            date: null
          }
        });
        
        console.log(`üóëÔ∏è Se eliminaron ${deleted1 + deleted2} configuraciones generales anteriores`);
      } catch (deleteError) {
        console.error('Error al eliminar configuraciones generales anteriores:', deleteError);
      }
    }

    // Procesar cada d√≠a en la configuraci√≥n recibida
    const updatedSettings = [];
    
    for (const dayKey in availability) {
      const dayOfWeek = parseInt(dayKey, 10);
      const hours = availability[dayKey];
      
      if (isNaN(dayOfWeek) || !Array.isArray(hours)) {
        console.log(`‚ö†Ô∏è Datos inv√°lidos para d√≠a ${dayKey}:`, hours);
        continue;
      }
      
      if (specificDate) {
        console.log(`üìù Procesando d√≠a ${dayOfWeek}, fecha espec√≠fica: ${specificDate}`);
      } else {
        console.log(`üìù Procesando d√≠a ${dayOfWeek}, fecha: No especificada`);
      }
      console.log(`üìù Horas disponibles: ${hours.join(', ')}`);
      
      try {
        // Crear nuevo registro directamente
        const newRecord = {
          // IMPORTANTE: Usar el ID decodificado (userId) en lugar del ID del manager
          managerId: decodedManagerId,
          dayOfWeek,
          hourSlots: hours
        };
        
        // Si hay fecha espec√≠fica, incluirla en date
        if (specificDate) {
          newRecord.date = specificDate;
        } else {
          newRecord.date = null;
        }
        
        console.log('üìä Datos a guardar:', JSON.stringify(newRecord));
        
        const availabilityRecord = await SpaceAvailability.create(newRecord);
        
        console.log(`‚úÖ Creado registro para d√≠a ${dayOfWeek}:`, availabilityRecord.id);
        console.log('üìä Datos guardados:', {
          id: availabilityRecord.id,
          managerId: availabilityRecord.managerId,
          dayOfWeek: availabilityRecord.dayOfWeek,
          date: availabilityRecord.date,
          hoursCount: hours.length
        });
        
        updatedSettings.push(availabilityRecord);
      } catch (error) {
        console.error(`‚ùå Error al guardar d√≠a ${dayOfWeek}:`, error);
      }
    }

    return res.status(200).json({
      success: true,
      message: `Disponibilidad ${specificDate ? 'para fecha espec√≠fica' : 'recurrente'} actualizada correctamente`,
      updatedSettings: updatedSettings.map(record => ({
        id: record.id,
        managerId: record.managerId,
        dayOfWeek: record.dayOfWeek,
        date: record.date,
        hourSlots: record.hourSlots
      }))
    });
  } catch (error) {
    console.error('Error al actualizar disponibilidad:', error);
    return res.status(500).json({ 
      success: false, 
      message: 'Error al actualizar configuraci√≥n de disponibilidad',
      error: error.message
    });
  }
};

// Obtener slots bloqueados
exports.getBlockedSlots = async (req, res) => {
  try {
    const { managerId } = req.params;
    
    // Decodificar el ID si viene codificado en la URL
    const decodedManagerId = decodeURIComponent(managerId);
    
    console.log(`üîç Buscando slots bloqueados para manager: ${decodedManagerId}`);
    
    // Verificar si el manager existe
    const manager = await Manager.findOne({ where: { userId: decodedManagerId } });
    if (!manager) {
      return res.status(404).json({ success: false, message: 'Gestor cultural no encontrado' });
    }

    console.log(`‚úÖ Manager encontrado: ${manager.id} (userId: ${manager.userId})`);

    // Buscar slots bloqueados por userId (formato OAuth)
    const blockedSlotsByUserId = await BlockedSlot.findAll({ 
      where: { managerId: manager.userId },
      order: [['hour', 'ASC']]
    });
    
    console.log(`üìã Encontrados ${blockedSlotsByUserId.length} slots bloqueados por userId`);
    
    // Buscar slots bloqueados por id (formato UUID)
    const blockedSlotsById = await BlockedSlot.findAll({ 
      where: { managerId: manager.id },
      order: [['hour', 'ASC']]
    });
    
    console.log(`üìã Encontrados ${blockedSlotsById.length} slots bloqueados por id`);
    
    // Combinar resultados (eliminando duplicados)
    const allSlots = [...blockedSlotsByUserId];
    
    // Agregar slots por id solo si no est√°n ya incluidos
    for (const slot of blockedSlotsById) {
      // Crear una clave √∫nica que incluya fecha o d√≠a + hora
      const slotKey = slot.date 
        ? `${slot.date}-${slot.hour}` 
        : `${slot.day}-${slot.hour}`;
      
      const isDuplicate = allSlots.some(existingSlot => {
        const existingKey = existingSlot.date 
          ? `${existingSlot.date}-${existingSlot.hour}` 
          : `${existingSlot.day}-${existingSlot.hour}`;
        
        return existingKey === slotKey;
      });
      
      if (!isDuplicate) {
        allSlots.push(slot);
      }
    }
    
    console.log(`üìã Total de slots √∫nicos: ${allSlots.length}`);
    
    // Mostrar detalles de cada slot para diagn√≥stico
    allSlots.forEach((slot, index) => {
      console.log(`üìå Slot ${index + 1}:`, {
        id: slot.id,
        managerId: slot.managerId,
        hour: slot.hour,
        day: slot.day,
        dayName: slot.dayName,
        date: slot.date,
        isRecurring: slot.isRecurring
      });
    });
    
    // Formatear los resultados para el frontend
    const formattedSlots = allSlots.map(slot => {
      // Usar la hora tal como viene
      const hourNum = slot.hour;
      
      // Si el slot tiene fecha espec√≠fica, usarla
      if (slot.date) {
        return {
          id: slot.id,
          date: slot.date,
          hour: hourNum,
          isRecurring: false, // Slots con fecha espec√≠fica nunca son recurrentes
          managerId: slot.managerId // Agregar managerId para diagn√≥stico
        };
      }
      
      // Para slots recurrentes (por d√≠a de la semana)
      // CORRECCI√ìN: Usar el d√≠a guardado en la base de datos en lugar del d√≠a actual
      // Si el slot no tiene d√≠a definido, usar el d√≠a actual como fallback
      const today = new Date();
      const slotDay = slot.day !== undefined ? slot.day : today.getDay();
      
      return {
        id: slot.id,
        day: slotDay,
        dayName: slot.dayName, // Incluir el nombre del d√≠a si est√° disponible
        hour: hourNum,
        isRecurring: Boolean(slot.isRecurring),
        managerId: slot.managerId // Agregar managerId para diagn√≥stico
      };
    });

    return res.status(200).json({
      success: true,
      blockedSlots: formattedSlots
    });
  } catch (error) {
    console.error('Error al obtener slots bloqueados:', error);
    return res.status(500).json({ 
      success: false, 
      message: 'Error al obtener slots bloqueados',
      error: error.message
    });
  }
};

// Obtener slots bloqueados con formato detallado
exports.getBlockedSlotsDetailed = async (req, res) => {
  try {
    const { managerId } = req.params;
    
    // Decodificar el ID si viene codificado en la URL
    const decodedManagerId = decodeURIComponent(managerId);
    
    console.log(`üîç Buscando slots bloqueados detallados para manager: ${decodedManagerId}`);
    
    // Buscar todos los slots bloqueados
    let allSlots = [];
    
    // Buscar por userId (formato OAuth)
    const slotsByUserId = await BlockedSlot.findAll({
      where: { managerId: decodedManagerId },
      order: [['hour', 'ASC']]
    });
    
    console.log(`üìã Encontrados ${slotsByUserId.length} slots por userId`);
    allSlots = [...slotsByUserId];
    
    // Buscar tambi√©n por el manager.id (formato UUID) si existe
    const manager = await Manager.findOne({ where: { userId: decodedManagerId } });
    if (manager) {
      const slotsById = await BlockedSlot.findAll({
        where: { managerId: manager.id },
        order: [['hour', 'ASC']]
      });
      
      console.log(`üìã Encontrados ${slotsById.length} slots adicionales por id`);
      
      // Agregar slots que no est√©n duplicados
      for (const slot of slotsById) {
        const isDuplicate = allSlots.some(
          existingSlot => existingSlot.hour === slot.hour
        );
        
        if (!isDuplicate) {
          allSlots.push(slot);
        }
      }
    }
    
    console.log(`üìã Total de slots √∫nicos: ${allSlots.length}`);
    
    // Agrupar por fecha usando createdAt
    const slotsByDate = {};
    
    allSlots.forEach(slot => {
      // Usar la hora tal como viene
      const hourNum = slot.hour;
      
      // Usar createdAt para obtener la fecha correcta
      const createdDate = new Date(slot.createdAt);
      const date = createdDate.toISOString().split('T')[0];
      
      console.log(`üìÖ Slot creado en: ${date}, hora: ${hourNum}`);
      
      // Inicializar array para esta fecha si no existe
      if (!slotsByDate[date]) {
        slotsByDate[date] = [];
      }
      
      // Agregar slot a la fecha correspondiente
      slotsByDate[date].push({
        id: slot.id,
        hour: hourNum,
        isRecurring: Boolean(slot.isRecurring),
        managerId: slot.managerId,
        createdAt: slot.createdAt
      });
    });
    
    // Convertir a formato m√°s amigable para el frontend
    const formattedResult = Object.keys(slotsByDate).map(date => {
      // Crear objeto Date para obtener el d√≠a de la semana
      const dateObj = new Date(date);
      const dayOfWeek = dateObj.getDay(); // 0: domingo, 1: lunes, etc.
      const dayNames = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];
      
      return {
        date,
        dayOfWeek,
        dayName: dayNames[dayOfWeek],
        slots: slotsByDate[date].sort((a, b) => a.hour - b.hour) // Ordenar por hora
      };
    }).sort((a, b) => new Date(a.date) - new Date(b.date)); // Ordenar por fecha
    
    return res.status(200).json({
      success: true,
      blockedDates: formattedResult,
      totalSlots: allSlots.length
    });
  } catch (error) {
    console.error('Error al obtener slots bloqueados detallados:', error);
    return res.status(500).json({ 
      success: false, 
      message: 'Error al obtener slots bloqueados detallados',
      error: error.message
    });
  }
};

// Bloquear slot
exports.blockSlot = async (req, res) => {
  try {
    console.log('‚≠ê Iniciando blockSlot con par√°metros:', {
      managerId: req.params.managerId,
      body: req.body
    });
    
    const { managerId } = req.params;
    const { date, hour, day, dayName, isRecurring = false } = req.body;
    
    // Verificar datos recibidos
    if (hour === undefined) {
      console.log('‚ùå Error: Datos incompletos para bloquear slot');
      return res.status(400).json({
        success: false,
        message: 'Datos inv√°lidos para bloquear slot: se requiere hora'
      });
    }
    
    console.log('üìÖ Datos recibidos para bloquear slot:', {
      date, hour, day, dayName, isRecurring
    });
    
    // Convertir hora a entero
    const hourNum = parseInt(hour);
    console.log('üïí Hora validada:', hourNum);
    
    // Validar que la hora est√© dentro del rango v√°lido (0-23)
    if (hourNum < 0 || hourNum > 23) {
      return res.status(400).json({
        success: false,
        message: 'La hora debe estar entre 0 y 23'
      });
    }
    
    // Decodificar el ID si viene codificado en la URL
    const decodedManagerId = decodeURIComponent(managerId);
    console.log('üîç ID decodificado:', decodedManagerId);
    
    // Buscar el manager por userId (para IDs de OAuth)
    let manager = await Manager.findOne({ where: { userId: decodedManagerId } });
    
    if (manager) {
      console.log('‚úÖ Manager encontrado por userId:', {
        id: manager.id,
        userId: manager.userId
      });
    } else {
      // Si no se encuentra, intentar buscar directamente por ID (para UUIDs)
      manager = await Manager.findByPk(decodedManagerId);
      
      if (manager) {
        console.log('‚úÖ Manager encontrado por ID directo:', {
          id: manager.id,
          userId: manager.userId
        });
      } else {
        console.log('‚ö†Ô∏è Manager no encontrado, usando ID recibido directamente');
      }
    }
    
    // Si a√∫n no se encuentra, crear un slot bloqueado usando directamente el ID recibido
    if (!manager) {
      console.log('üîç Usando ID recibido directamente para bloquear slot');
      
      // Preparar datos para la creaci√≥n del slot
      const slotData = {
        managerId: decodedManagerId, // Usar el ID recibido directamente
        hour: hourNum,
        day: day !== undefined ? parseInt(day, 10) : undefined,
        dayName,
        date: date || null, // A√±adir fecha espec√≠fica si existe
        dateStr: date || null, // Guardar tambi√©n como string para compatibilidad
        isRecurring: date ? false : isRecurring // Si hay fecha espec√≠fica, no es recurrente
      };
      
      console.log('üìÖ Datos del slot a crear:', slotData);
      
      console.log('üîç Verificando si ya existe slot con datos:', slotData);
      
      // Verificar si ya existe un slot bloqueado
      const whereConditions = {
        managerId: decodedManagerId,
        hour: hourNum
      };
      
      // Si se especific√≥ una fecha espec√≠fica, buscar por fecha
      if (date) {
        whereConditions.date = date;
        console.log('üîç Buscando por fecha espec√≠fica:', date);
      } 
      // Si no hay fecha pero hay d√≠a, buscar por d√≠a
      else if (day !== undefined) {
        whereConditions.day = parseInt(day, 10);
        console.log('üîç Buscando por d√≠a recurrente:', day);
      }
      
      console.log('üîç Condiciones de b√∫squeda:', whereConditions);
      
      const existingSlot = await BlockedSlot.findOne({
        where: whereConditions
      });
      
      if (existingSlot) {
        console.log('‚ö†Ô∏è Este horario ya est√° bloqueado:', existingSlot.toJSON());
        return res.status(200).json({
          success: true,
          message: 'Este horario ya est√° bloqueado',
          blockedSlot: existingSlot
        });
      }
      
      console.log('‚úÖ Creando nuevo slot bloqueado con datos:', slotData);
      
      try {
        // Crear el slot bloqueado
        const blockedSlot = await BlockedSlot.create(slotData);
        console.log('‚úÖ Slot bloqueado creado:', blockedSlot.toJSON());
        
        return res.status(201).json({
          success: true,
          message: 'Horario bloqueado correctamente',
          blockedSlot
        });
      } catch (createError) {
        console.error('‚ùå Error al crear slot bloqueado:', createError);
        return res.status(500).json({
          success: false,
          message: 'Error al crear slot bloqueado',
          error: createError.message
        });
      }
    }
    
    // Preparar datos para la creaci√≥n del slot
    const slotData = {
      managerId: manager.userId, // Usar userId en lugar de id para mantener el formato OAuth
      hour: hourNum,
      day: day !== undefined ? parseInt(day, 10) : undefined,
      dayName,
      date: date || null, // A√±adir fecha espec√≠fica si existe
      isRecurring: date ? false : isRecurring // Si hay fecha espec√≠fica, no es recurrente
    };
    
    console.log('üìÖ Datos del slot a crear:', slotData);
    
    // Preparar condiciones de b√∫squeda para verificar si ya existe
    const whereCondition = {
      managerId: manager.userId, // Usar userId en lugar de id para mantener el formato OAuth
      hour: hourNum
    };
    
    // Si se especific√≥ una fecha espec√≠fica, incluirla en la condici√≥n
    if (date) {
      whereCondition.date = date;
      console.log('üîç Buscando por fecha espec√≠fica:', date);
    } 
    // Si no hay fecha pero hay d√≠a, buscar por d√≠a
    else if (day !== undefined) {
      whereCondition.day = parseInt(day, 10);
      console.log('üîç Buscando por d√≠a recurrente:', day);
    }
    
    console.log('üîç Condiciones de b√∫squeda:', whereCondition);
    
    // Verificar si el slot ya est√° bloqueado
    const existingSlot = await BlockedSlot.findOne({
      where: whereCondition
    });
    
    if (existingSlot) {
      console.log('‚ö†Ô∏è Este horario ya est√° bloqueado:', existingSlot.toJSON());
      return res.status(200).json({
        success: true,
        message: 'Este horario ya est√° bloqueado',
        blockedSlot: existingSlot
      });
    }
    
    console.log('‚úÖ Creando nuevo slot bloqueado con datos:', slotData);
    
    try {
      // Crear el slot bloqueado
      const blockedSlot = await BlockedSlot.create(slotData);
      console.log('‚úÖ Slot bloqueado creado:', blockedSlot.toJSON());
      
      return res.status(201).json({
        success: true,
        message: 'Horario bloqueado correctamente',
        blockedSlot
      });
    } catch (createError) {
      console.error('‚ùå Error al crear slot bloqueado:', createError);
      return res.status(500).json({
        success: false,
        message: 'Error al crear slot bloqueado',
        error: createError.message
      });
    }
  } catch (error) {
    console.error('‚ùå Error al bloquear slot:', error);
    return res.status(500).json({ 
      success: false, 
      message: 'Error al bloquear slot',
      error: error.message
    });
  }
};

// Desbloquear slot
exports.unblockSlot = async (req, res) => {
  try {
    console.log('‚≠ê Iniciando unblockSlot con par√°metros:', {
      managerId: req.params.managerId,
      body: req.body
    });
    
    const { managerId } = req.params;
    const { date, hour } = req.body;
    
    if (hour === undefined) {
      console.log('‚ùå Error: Datos incompletos para desbloquear slot');
      return res.status(400).json({
        success: false,
        message: 'Se requiere la hora para desbloquear slot'
      });
    }
    
    // Validar hora (0-23)
    const hourNum = parseInt(hour);
    if (isNaN(hourNum) || hourNum < 0 || hourNum > 23) {
      return res.status(400).json({
        success: false,
        message: 'La hora debe ser un n√∫mero entre 0 y 23'
      });
    }
    
    // Decodificar el ID si viene codificado en la URL
    const decodedManagerId = decodeURIComponent(managerId);
    console.log('üîç ID decodificado:', decodedManagerId);
    
    // Buscar el manager por userId (para IDs de OAuth)
    let manager = await Manager.findOne({ where: { userId: decodedManagerId } });
    
    if (manager) {
      console.log('‚úÖ Manager encontrado por userId:', {
        id: manager.id,
        userId: manager.userId
      });
    } else {
      // Si no se encuentra, intentar buscar directamente por ID (para UUIDs)
      manager = await Manager.findByPk(decodedManagerId);
      
      if (manager) {
        console.log('‚úÖ Manager encontrado por ID directo:', {
          id: manager.id,
          userId: manager.userId
        });
      } else {
        console.log('‚ö†Ô∏è Manager no encontrado, buscando directamente en BlockedSlots');
      }
    }
    
    // Si a√∫n no se encuentra, intentar buscar en la tabla BlockedSlots directamente
    if (!manager) {
      console.log('üîç Buscando directamente en BlockedSlots con managerId:', decodedManagerId);
      
      // Preparar condiciones de b√∫squeda para BlockedSlot
      const whereCondition = {
        hour: hourNum,
        managerId: decodedManagerId
      };
      
      // Si se especific√≥ una fecha espec√≠fica, incluirla en la condici√≥n
      if (date) {
        whereCondition.date = date;
        console.log('üîç Buscando por fecha espec√≠fica:', date);
      }
      
      console.log('üîç Buscando slot bloqueado con condiciones:', whereCondition);
      
      // Primero verificar si existe el slot
      const existingSlot = await BlockedSlot.findOne({
        where: whereCondition
      });
      
      if (existingSlot) {
        console.log('‚úÖ Slot bloqueado encontrado:', existingSlot.toJSON());
      } else {
        console.log('‚ùå No se encontr√≥ ning√∫n slot bloqueado con estas condiciones');
      }
      
      // Intentar eliminar el slot
      const deleteResult = await BlockedSlot.destroy({
        where: whereCondition
      });
      
      if (deleteResult > 0) {
        console.log(`‚úÖ Se eliminaron ${deleteResult} slots bloqueados`);
        return res.status(200).json({
          success: true,
          message: `Se desbloquearon ${deleteResult} horarios`
        });
      } else {
        console.log('‚ùå No se elimin√≥ ning√∫n slot bloqueado');
        return res.status(404).json({
          success: false,
          message: 'No se encontr√≥ el horario bloqueado'
        });
      }
    }
    
    // Si encontramos el manager, usar su userId (formato OAuth) para buscar el slot bloqueado
    // Preparar condiciones de b√∫squeda
    const whereCondition = {
      hour: hourNum,
      managerId: manager.userId // Usar userId en lugar de id para mantener el formato OAuth
    };
    
    // Si se especific√≥ una fecha espec√≠fica, incluirla en la condici√≥n
    if (date) {
      whereCondition.date = date;
      console.log('üîç Buscando por fecha espec√≠fica:', date);
    }
    
    console.log('üîç Buscando slot bloqueado con condiciones (manager encontrado):', whereCondition);
    
    // Verificar si existe el slot
    const existingSlot = await BlockedSlot.findOne({
      where: whereCondition
    });
    
    if (existingSlot) {
      console.log('‚úÖ Slot bloqueado encontrado:', existingSlot.toJSON());
    } else {
      console.log('‚ùå No se encontr√≥ ning√∫n slot bloqueado con estas condiciones');
      
      // Intentar buscar con el ID del manager en lugar del userId
      const alternativeCondition = {
        hour: hourNum,
        managerId: manager.id
      };
      
      // Si se especific√≥ una fecha espec√≠fica, incluirla en la condici√≥n alternativa
      if (date) {
        alternativeCondition.date = date;
      }
      
      console.log('üîç Buscando con condiciones alternativas:', alternativeCondition);
      
      const alternativeSlot = await BlockedSlot.findOne({
        where: alternativeCondition
      });
      
      if (alternativeSlot) {
        console.log('‚úÖ Slot bloqueado encontrado con ID alternativo:', alternativeSlot.toJSON());
      } else {
        console.log('‚ùå No se encontr√≥ ning√∫n slot bloqueado con condiciones alternativas');
      }
    }
    
    // Intentar eliminar el slot
    const deleteResult = await BlockedSlot.destroy({
      where: whereCondition
    });
    
    if (deleteResult > 0) {
      console.log(`‚úÖ Se eliminaron ${deleteResult} slots bloqueados`);
      return res.status(200).json({
        success: true,
        message: `Se desbloquearon ${deleteResult} horarios`
      });
    } else {
      // Si no se elimin√≥ ning√∫n slot, intentar con el ID del manager
      const alternativeCondition = {
        hour: hourNum,
        managerId: manager.id
      };
      
      // Si se especific√≥ una fecha espec√≠fica, incluirla en la condici√≥n alternativa
      if (date) {
        alternativeCondition.date = date;
      }
      
      const alternativeDeleteResult = await BlockedSlot.destroy({
        where: alternativeCondition
      });
      
      if (alternativeDeleteResult > 0) {
        console.log(`‚úÖ Se eliminaron ${alternativeDeleteResult} slots bloqueados (usando ID alternativo)`);
        return res.status(200).json({
          success: true,
          message: `Se desbloquearon ${alternativeDeleteResult} horarios`
        });
      } else {
        console.log('‚ùå No se elimin√≥ ning√∫n slot bloqueado');
        return res.status(404).json({
          success: false,
          message: 'No se encontr√≥ el horario bloqueado'
        });
      }
    }
  } catch (error) {
    console.error('‚ùå Error al desbloquear slot:', error);
    return res.status(500).json({ 
      success: false, 
      message: 'Error al desbloquear slot',
      error: error.message
    });
  }
};

// Desbloquear slot por ID espec√≠fico
exports.unblockSlotById = async (req, res) => {
  try {
    const { slotId } = req.params;
    
    console.log(`‚≠ê Intentando desbloquear slot por ID: ${slotId}`);
    
    // Buscar el slot por ID
    const slot = await BlockedSlot.findByPk(slotId);
    
    if (!slot) {
      console.log(`‚ùå No se encontr√≥ el slot con ID: ${slotId}`);
      return res.status(404).json({
        success: false,
        message: 'No se encontr√≥ el slot con el ID especificado'
      });
    }
    
    console.log(`‚úÖ Slot encontrado:`, {
      id: slot.id,
      managerId: slot.managerId,
      date: slot.dateStr || slot.date,
      hour: slot.hour
    });
    
    // Eliminar el slot
    await slot.destroy();
    
    console.log(`üóëÔ∏è Slot eliminado correctamente`);
    
    return res.status(200).json({
      success: true,
      message: 'Horario desbloqueado correctamente',
      slotInfo: {
        id: slot.id,
        date: slot.dateStr || slot.date,
        hour: slot.hour
      }
    });
  } catch (error) {
    console.error('‚ùå Error al desbloquear slot por ID:', error);
    return res.status(500).json({ 
      success: false, 
      message: 'Error al desbloquear horario',
      error: error.message
    });
  }
};

// Obtener eventos del espacio cultural
exports.getEvents = async (req, res) => {
  try {
    const { managerId } = req.params;
    
    // Verificar si el manager existe
    const manager = await Manager.findOne({ where: { userId: managerId } });
    if (!manager) {
      return res.status(404).json({ success: false, message: 'Gestor cultural no encontrado' });
    }

    // Buscar eventos del espacio cultural
    const events = await Event.findAll({
      where: { spaceId: manager.id },
      order: [['fecha', 'ASC']]
    });

    return res.status(200).json({
      success: true,
      events
    });
  } catch (error) {
    console.error('Error al obtener eventos:', error);
    return res.status(500).json({ 
      success: false, 
      message: 'Error al obtener eventos del espacio cultural',
      error: error.message
    });
  }
};

// Restaurar configuraci√≥n (eliminar todos los slots bloqueados)
exports.resetBlockedSlots = async (req, res) => {
  try {
    const { managerId } = req.params;
    
    // Decodificar el ID si viene codificado en la URL
    const decodedManagerId = decodeURIComponent(managerId);
    
    console.log(`üîÑ Restaurando configuraci√≥n para manager: ${decodedManagerId}`);
    
    // Verificar si el manager existe
    const manager = await Manager.findOne({ where: { userId: decodedManagerId } });
    if (!manager) {
      return res.status(404).json({ success: false, message: 'Gestor cultural no encontrado' });
    }

    console.log(`‚úÖ Manager encontrado: ${manager.id} (userId: ${manager.userId})`);

    // Eliminar slots bloqueados por userId (formato OAuth)
    const deletedByUserId = await BlockedSlot.destroy({ 
      where: { managerId: manager.userId }
    });
    
    console.log(`üóëÔ∏è Eliminados ${deletedByUserId} slots bloqueados por userId`);
    
    // Eliminar slots bloqueados por id (formato UUID)
    const deletedById = await BlockedSlot.destroy({ 
      where: { managerId: manager.id }
    });
    
    console.log(`üóëÔ∏è Eliminados ${deletedById} slots bloqueados por id`);
    
    // Restaurar disponibilidad por defecto
    // Primero eliminar configuraci√≥n existente
    await SpaceAvailability.destroy({
      where: { managerId: manager.id }
    });
    
    // Crear disponibilidad por defecto (todos los d√≠as, horario comercial)
    const availability = {};
    for (let day = 0; day <= 6; day++) {
      // Horario de 8am a 8pm por defecto
      const availableHours = Array.from({ length: 13 }, (_, i) => i + 8);
      availability[day] = availableHours;
      
      // Guardar en la base de datos
      await SpaceAvailability.create({
        managerId: manager.id,
        dayOfWeek: day,
        availableHours
      });
    }
    
    return res.status(200).json({
      success: true,
      message: 'Configuraci√≥n restaurada correctamente',
      deletedSlots: deletedByUserId + deletedById,
      availability
    });
  } catch (error) {
    console.error('Error al restaurar configuraci√≥n:', error);
    return res.status(500).json({ 
      success: false, 
      message: 'Error al restaurar configuraci√≥n',
      error: error.message
    });
  }
};
